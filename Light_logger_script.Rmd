---
title: "logger"
author: "Shayle Matsuda"
date: "1/5/2022"
output: html_document
---
Light and Temp loggers 
Original script by M. Hoban
```{r}
#rm(list=ls())

library(fs)
library(lubridate)# for date parsing
library(tidyverse)

#load data
csv_files <- dir_ls("logger_files",glob="*.CSV",recurse = TRUE)

# map_dfr on the list of csv files
# the function loads each file, does some transformation, 
# and returns the dataframe with an associated logger ID
# Then all those dataframes get smashed together into one big one.
loggers <- map_dfr(csv_files,function(csv) {
  # let's try to get the logger id
  # we'll start with the csv filename without any leading
  # directories and without the .csv at the end
  logger_id <- path_ext_remove(path_file(csv))
  # now, let's make sure that logger id looks like this: XXXX_XXXXX
  # Regular expressions are a whole huge complicated thing, but
  # "^(._)_" basically says: 
  # at the start of the string, do I have some characters followed by an underscore
  # the parentheses are used to "capture" those characters that come before the underscore
  # str_detect just says whether the logger id looks like we want it to
  if (str_detect(logger_id,"^(.+)_")) {
    # if it does look like we want it to, pull out just the part
    # before the underscore. str_match returns a matrix and the second column
    # contains what's between the parentheses
    # for much more detail, check out the help for str_match and str_detect
    logger_id <- str_match(logger_id,"^(.+)_")[1,2]
  }
  
  # this is where the magic happens. Tidyverse uses a thing called a "pipe" (the %>% that you see below)
  # The pipe allows you to chain together multiple functions with the result of one being "piped" into
  # the input of the next. The way pipes work is that if you have a function called do_thing that takes an argument,
  # calling do_thing(x) is the same as calling x %>% do_thing(). You can do it multiple times:
  # x %>% do_thing() %>% do_thing() %>% do_thing()
  # would be the same as do_thing(do_thing(do_thing(x)))
  # In pipes, you can use . (dot) to refer to the thing being piped in
  # so in the above example . refers to x, so x %>% do_thing() is the same as x %>% do_thing(.)
  # It'll really help to read some intro material on the tidyverse because it's very elegant and 
  # simple but it can also be very confusing
  return(
    # first we read the csv file
    read_csv(csv,
             skip = 9, # skip 9 rows
             col_names = c("scan_number","date","time","raw","calibrated"), # name our columns
             col_types = "nccnn") %>% # force it to read the columns as numeric, character, character, numeric, numeric ("nccnn"
                                      # note the %>% on the line above. That will "pipe" the csv file into the next function
      # now we trim off whitespace from our dates and times
      # mutate is used to change columns
      # across(where(is.character)) chooses just columns containing character string
      # str_trim cuts whitespace, so something like "22/12/2017 " turns into just "22/12/2017"
      mutate(across(where(is.character), str_trim)) %>% 
      # now we make a new column in POSIXct format, parsing the date and time using the two different
      # formats we might expect to see (two digit year or three digit year)
      # remember, str_c just smashes two strings together, so I'm smashing the date and time together with a space between
      # we also create a factor column indicating the logger id that we determined above
      mutate(
        datetime = parse_date_time(str_c(date," ",time), orders = c("d/m/y H:M:S","d/m/Y H:M:S"),tz="HST"),
        logger = factor(str_c("logger_",logger_id))
      ) %>%
      # select just lets us pull out specific columns
      # these are the ones we want
      dplyr::select(logger, datetime, raw, calibrated)   # *******july 13 2022 the select() function is throwing errors w/o dplyr call ******
  )
  
})

# make wide
loggers_wide <- loggers %>%
  dplyr::select(-raw) %>% # get rid of the raw column
  pivot_wider(names_from="logger",values_from="calibrated") %>%
  arrange(datetime)


# trim out the time frame of the experiment, Oct 29-Jan 8. and remove data during readout times. 
# subset date time of experiment
loggers_wide <- loggers_wide %>%
                        filter(datetime >= as.Date('2017-10-29') & datetime <= as.Date('2018-01-07')) #

loggers_wide$date<-date(loggers_wide$datetime) #pull out date

#cut out times when data was pulled from logger, #this removes some of it but not all and not sure why but oh well?
  loggers_wide<-loggers_wide%>%
     filter(!(date == '2017-11-01'))%>%
     filter(!(date == '2017-11-18'))%>%
     filter(!(date == '2017-11-29'))%>%
     filter(!(date == '2017-11-04'))%>%
     filter(!(date == '2017-11-06'))%>%
     filter(!(date == '2017-12-07'))%>%
     filter(!(date == '2017-12-08'))

# save the wide version of the file to CSV
#write_csv(loggers_wide,"loggers_wide_20220713.csv")

#REMOVE LOGGER 6377 UNLESS YOU LOCATE CALIBRATION FILE
loggers_wide = subset(loggers_wide, select = -c(logger_6377) )


Mcap.light<-loggers_wide #make a copy

##############
#calibrate the loggers. then melt data and add in Treatment for light groups. then plot by those. 

# logger 2488 calibration: y=0.06069x R^2=0.999
Mcap.light$logger_2488CAL <- Mcap.light$logger_2488 * 0.06069
# logger 6377 calibration: y=0.1437x R^2=.3 <-  something up DO NOT INCLUDE this logger!
#Mcap.light$logger_6377CAL <- Mcap.light$logger_6377 * 0.1437
# logger 6378 calibration: y=0.1182x R^2=0.999
Mcap.light$logger_6378CAL <- Mcap.light$logger_6378 * 0.1182
# logger 7272 calibration: y=0.06658x R^2=0.999
Mcap.light$logger_7272CAL <- Mcap.light$logger_7272 * 0.06658
# logger 7274 calibration: y=0.06628x R^2=0.999
Mcap.light$logger_7274CAL <- Mcap.light$logger_7274 * 0.06628
# logger 7277 calibration: y=0.06787x R^2=0.999
Mcap.light$logger_7277CAL <- Mcap.light$logger_7277 * 0.06787
# logger 7278 calibration: y=0.05946x R^2=0.999
Mcap.light$logger_7278CAL <- Mcap.light$logger_7278 * 0.05946
# logger 7279 calibration: y=0.07278x R^2=0.999
Mcap.light$logger_7279CAL <- Mcap.light$logger_7279 * 0.07278
# logger 7280 calibration: y=0.06481x R^2=0.999
Mcap.light$logger_7280CAL <- Mcap.light$logger_7280 * 0.06481
# logger 10956 calibration: y=0.05712x R^2=1
Mcap.light$logger_10956CAL <- Mcap.light$logger_10956 * 0.05712
# logger 10957 calibration: y=0.05758x R^2=0.999
Mcap.light$logger_10957CAL <- Mcap.light$logger_10957 * 0.05758
# logger 10959 calibration: y=0.06052x R^2=1
Mcap.light$logger_10959CAL <- Mcap.light$logger_10959 * 0.06052

Mcap.light.2<- subset(Mcap.light, select = c( 1, 18:28)) #keep cols you need

logger.df<-read.csv("UROP_logger_locations.csv")

#melt the df and then add metadata
Mcap.light.2.melt<-
  Mcap.light.2%>% 
   pivot_longer(
    cols=!datetime,
    names_to="Light.logger",
    values_to = "Light")

#merge with metadata
Mcap.light.2.melt.meta<-inner_join(Mcap.light.2.melt, logger.df, by="Light.logger")
Mcap.light.2.melt.meta$Light.logger<-as.factor(Mcap.light.2.melt.meta$Light.logger)
Mcap.light.2.melt.meta$Shade<-as.factor(Mcap.light.2.melt.meta$Shade)
Mcap.light.2.melt.meta$Temp.logger<-as.factor(Mcap.light.2.melt.meta$Temp.logger)
Mcap.light.2.melt.meta$Tank<-as.factor(Mcap.light.2.melt.meta$Tank)

light_plot<-ggplot(data=Mcap.light.2.melt.meta, aes(x=datetime, y=Light, group = Shade, color=Shade)) +
  # geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
  #               width=0.1, show.legend = F)+
  #geom_point(aes(color=Treatment), size=4, show.legend = F)+
  geom_line(aes(color=Shade), linetype=2, show.legend = T)+
  #scale_color_manual(values=c("dodgerblue3", "darkred"))+
  xlab("") + #Label the X Axis
  #ylim(0, 11) + #set Y limits
  #scale_y_log10()+
  theme_bw() + #Set the ITSkground color
  theme(axis.line = element_line(color = 'black'), #Set the axes color
        axis.title=element_text(size=14,face="bold"), #Set axis format
        panel.border = element_blank(), #Set the border
        panel.grid.major = element_blank(), #Set the major gridlines
        panel.grid.minor = element_blank(), #Set the minor gridlines
        text = element_text(size=18),  # set element text
        plot.background =element_blank(), #Set the plot ITSkground
        legend.key = element_blank()) + #Set plot legend key
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_rect(colour = "black", size=1))+
  theme(aspect.ratio=1)+
  ylab(expression(paste("Light"))) +
  ggtitle("UROP light")+
  theme(plot.title = element_text(size=20, face = "italic"));light_plot 

light_plot+facet_wrap(~Shade, scales = "free_y")
light_plot + xlim(as_datetime("2017-11-30"),  as_datetime("2017-12-01"))

light_plot<-ggplot(data=Mcap.light.2.melt.meta, aes(x=datetime, y=Light, color=Light.logger)) +
  # geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
  #               width=0.1, show.legend = F)+
  #geom_point(aes(color=Treatment), size=4, show.legend = F)+
  geom_line(aes(color=Light.logger), linetype=2, show.legend = T)+
  #scale_color_manual(values=c("dodgerblue3", "darkred"))+
  xlab("") + #Label the X Axis
  #ylim(0, 11) + #set Y limits
  #scale_y_log10()+
  theme_bw() + #Set the ITSkground color
  theme(axis.line = element_line(color = 'black'), #Set the axes color
        axis.title=element_text(size=14,face="bold"), #Set axis format
        panel.border = element_blank(), #Set the border
        panel.grid.major = element_blank(), #Set the major gridlines
        panel.grid.minor = element_blank(), #Set the minor gridlines
        text = element_text(size=18),  # set element text
        plot.background =element_blank(), #Set the plot ITSkground
        legend.key = element_blank()) + #Set plot legend key
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_rect(colour = "black", size=1))+
  theme(aspect.ratio=1)+
  ylab(expression(paste("Light"))) +
  ggtitle("UROP light")+
  theme(plot.title = element_text(size=20, face = "italic"));light_plot 

light_plot+facet_wrap(~Shade)
light_plot + xlim(as_datetime("2017-11-30"),  as_datetime("2017-12-01"))


light_plot<-ggplot(data=Mcap.light.2.melt.meta, aes(x=datetime, y=Light, group = Shade, color=Shade)) +
  # geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
  #               width=0.1, show.legend = F)+
  #geom_point(aes(color=Treatment), size=4, show.legend = F)+
  geom_smooth(aes(color=Shade), linetype=2, show.legend = T)+
  #scale_color_manual(values=c("dodgerblue3", "darkred"))+
  xlab("") + #Label the X Axis
  #ylim(0, 11) + #set Y limits
  #scale_y_log10()+
  theme_bw() + #Set the ITSkground color
  theme(axis.line = element_line(color = 'black'), #Set the axes color
        axis.title=element_text(size=14,face="bold"), #Set axis format
        panel.border = element_blank(), #Set the border
        panel.grid.major = element_blank(), #Set the major gridlines
        panel.grid.minor = element_blank(), #Set the minor gridlines
        text = element_text(size=18),  # set element text
        plot.background =element_blank(), #Set the plot ITSkground
        legend.key = element_blank()) + #Set plot legend key
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_rect(colour = "black", size=1))+
  theme(aspect.ratio=1)+
  ylab(expression(paste("Light"))) +
  ggtitle("UROP light")+
  theme(plot.title = element_text(size=20, face = "italic"));light_plot



Mcap.light.2.melt.meta <- Mcap.light.2.melt.meta %>%
  mutate(time.point = case_when(date(datetime) < "2017-11-29" ~ "T1",
                                date(datetime) >="2017-11-29" ~ "T2"))

#model testing if loggers differ within treatment
mod<- lm(Light~Shade:Light.logger, data=Mcap.light.2.melt.meta)
  anova(mod)
  
  mod<- lm(Light~Shade*datetime, data=Mcap.light.2.melt.meta)
  anova(mod)
  
#add time point column 
  
```


```{r}
### REDO LIGHT CALCULATIONS SEPARATELY FOR EACH TIME POINT

# Calculate average daily light integral for each shade treatment

# number of loggers
Mcap.light.2.melt.meta %>%
  distinct(Light.logger, Shade) %>%
  arrange(Shade)
# 11 loggers

light_res <- Mcap.light.2.melt.meta %>%
  group_by(Light.logger, date = date(datetime), Shade) %>%     # group by light logger and day
  summarise(dli = sum(Light, na.rm = T) / n() * 0.0864) %>%    # calc DLI for each logger on each day
  group_by(Shade) %>%                                          # group by shade treatment
  summarise(avg_dli = mean(dli))                               # calculate average
  
light_res %>%
  arrange(Shade)

light_res_bytimepoint <- Mcap.light.2.melt.meta %>%
  group_by(Light.logger, date = date(datetime), Shade) %>%     # group by light logger and day
  summarise(dli = sum(Light, na.rm = T) / n() * 0.0864) %>%    # calc DLI for each logger on each day
  group_by(Shade, timepoint = date < "2017-11-29") %>%         # group by shade treatment and timepoint (11-29cutoff)
  summarise(avg_dli = mean(dli)) %>%                           # calculate average
  mutate(timepoint = case_when(timepoint == TRUE ~ "T1",
                               timepoint == FALSE ~ "T2"))

# Write to file
write_csv(light_res_bytimepoint, path = "dli.csv")

#### calculate average daily maxima
avg_daily_maxima <- Mcap.light.2.melt.meta %>%
  group_by(Light.logger, date = date(datetime), Shade) %>%     # group by light logger and day
  summarise(max = max(Light)) %>%    # calc max for each logger on each day
  group_by(Shade, timepoint = date < "2017-11-29") %>%         # group by shade treatment and timepoint (11-29cutoff)
  summarise(avg_max = mean(max, na.rm = T)) %>%                           # calculate average
  mutate(timepoint = case_when(timepoint == TRUE ~ "T1",
                               timepoint == FALSE ~ "T2"))

# SHow that avg daily maxima and DLI are proportional
avg_daily_maxima %>%
  arrange(timepoint, avg_max) %>%
  full_join(light_res_bytimepoint) %>%
  pivot_longer(cols = c(avg_max, avg_dli)) %>%
  ggplot(aes(x = Shade, y = value, color = timepoint, group = timepoint)) +
  geom_point() + geom_line() +
  facet_wrap(~name, scales = "free_y")
```




#Temperature Loggers
If code is glitching, clean the environment and it will run
```{r}


#load data
csv_files <- dir_ls("temp_logger",glob="*.csv",recurse = TRUE)
# csv<-csv_files{1}

# map_dfr on the list of csv files
# the function loads each file, does some transformation, 
# and returns the dataframe with an associated logger ID
# Then all those dataframes get smashed together into one big one.
loggers <- map_dfr(csv_files,function(csv) {
  # let's try to get the logger id
  # we'll start with the csv filename without any leading
  # directories and without the .csv at the end
  logger_id <- path_ext_remove(path_file(csv))
  # now, let's make sure that logger id looks like this: XXXX_XXXXX
  # Regular expressions are a whole huge complicated thing, but
  # "^(._)_" basically says: 
  # at the start of the string, do I have some characters followed by an underscore
  # the parentheses are used to "capture" those characters that come before the underscore
  # str_detect just says whether the logger id looks like we want it to
  if (str_detect(logger_id,"^(.+)_")) {
    # if it does look like we want it to, pull out just the part
    # before the underscore. str_match returns a matrix and the second column
    # contains what's between the parentheses
    # for much more detail, check out the help for str_match and str_detect
    logger_id <- str_match(logger_id,"^(.+)_")[1,2]
  }
  
  # this is where the magic happens. Tidyverse uses a thing called a "pipe" (the %>% that you see below)
  # The pipe allows you to chain together multiple functions with the result of one being "piped" into
  # the input of the next. The way pipes work is that if you have a function called do_thing that takes an argument,
  # calling do_thing(x) is the same as calling x %>% do_thing(). You can do it multiple times:
  # x %>% do_thing() %>% do_thing() %>% do_thing()
  # would be the same as do_thing(do_thing(do_thing(x)))
  # In pipes, you can use . (dot) to refer to the thing being piped in
  # so in the above example . refers to x, so x %>% do_thing() is the same as x %>% do_thing(.)
  # It'll really help to read some intro material on the tidyverse because it's very elegant and 
  # simple but it can also be very confusing
  return(
    # first we read the csv file
     read_csv(
      csv,
      skip = 2,
      col_select=c(2,3),
      col_types = "ncncccc",
      col_names = FALSE
    ) %>%
      dplyr::rename("datetime" = 1, "Temp" = 2) %>%
      mutate(
        datetime = parse_date_time(datetime,"m/d/y I:M:S p", tz="HST"),
        logger = factor(str_c("logger_",logger_id))
      ) %>%
      # select just lets us pull out specific columns
      # these are the ones we want
      dplyr::select(logger, datetime, Temp)
  )
  
})

#remove duplicate rows (from when data was not wiped)
loggers<-loggers%>%distinct()

# make wide
loggers_wide <- loggers %>%
  #select(-raw) %>% # get rid of the raw column
  pivot_wider(names_from="logger",values_from="Temp") %>%
  arrange(datetime)

# save the wide version of the file to CSV
#write_csv(loggers_wide,"temploggers_wide_20220713.csv")

loggers_wide$date<-date(loggers_wide$datetime)

loggers_wide <- loggers_wide %>%
                        filter(datetime >= as.Date('2017-10-29') & datetime <= as.Date('2018-01-07')) #exp dates

#remove data when loggers pulled (same as light, confirm)
loggers_wide<-loggers_wide%>%
     filter(!(date == '2017-11-01'))%>%
     filter(!(date == '2017-11-18'))%>%
     filter(!(date == '2017-11-29'))%>%
     filter(!(date == '2017-11-04'))%>%
     filter(!(date == '2017-11-06'))%>%
    filter(!(date == '2017-12-04'))%>%
     filter(!(date == '2017-12-07'))%>%
     filter(!(date == '2017-12-08'))

loggers_wide<-dplyr::select(loggers_wide, -date) #now remove the date col


Mcap.temp<-loggers_wide #make a copy

##############

#you dont need this, no other metadata needed for only 4 loggers
# logger.df<-read.csv("UROP_logger_locations.csv")
# logger.df.temp<-select(logger.df, Light.logger, Temp.logger)  #melt the df and then add metadata
# #merge with metadata
# Mcap.temp.meta<-merge(Mcap.temp, logger.df)

library(reshape2)
#keep cols you need
#Mcap.temp.meta<-Mcap.temp.meta[-c(9)] cut?

###WORK THIS OUT
#melt
Mcap.temp.meta.melt <- melt(Mcap.temp, id = c("datetime"))
names(Mcap.temp.meta.melt)[2]<-"logger"
names(Mcap.temp.meta.melt)[3]<-"temp"

temp_plot<-ggplot(data=Mcap.temp.meta.melt, aes(x=datetime, y=temp, color=logger)) +
  # geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
  #               width=0.1, show.legend = F)+
  #geom_point(aes(color=Treatment), size=4, show.legend = F)+
  geom_line(aes(color=logger), linetype=2, show.legend = F)+
  #scale_color_manual(values=c("dodgerblue3", "darkred"))+
  xlab("") + #Label the X Axis
  #ylim(0, 11) + #set Y limits
  #scale_y_log10()+
  theme_bw() + #Set the ITSkground color
  theme(axis.line = element_line(color = 'black'), #Set the axes color
        axis.title=element_text(size=14,face="bold"), #Set axis format
        panel.border = element_blank(), #Set the border
        panel.grid.major = element_blank(), #Set the major gridlines
        panel.grid.minor = element_blank(), #Set the minor gridlines
        text = element_text(size=18),  # set element text
        plot.background =element_blank(), #Set the plot background
        legend.key = element_blank()) + #Set plot legend key
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_rect(colour = "black", size=1))+
  theme(aspect.ratio=1)+
  ylab(expression(paste("temp"))) +
  ggtitle("UROP temp")+
  theme(plot.title = element_text(size=20, face = "italic"));temp_plot 


temp_plot<-ggplot(data=Mcap.temp.meta.melt, aes(x=datetime, y=temp, color=logger)) +
  # geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
  #               width=0.1, show.legend = F)+
  #geom_point(aes(color=Treatment), size=4, show.legend = F)+
  geom_line(aes(color=logger), linetype=2, show.legend = F)+
  #scale_color_manual(values=c("dodgerblue3", "darkred"))+
  xlab("") + #Label the X Axis
  #ylim(0, 11) + #set Y limits
  #scale_y_log10()+
  theme_bw() + #Set the ITSkground color
  theme(axis.line = element_line(color = 'black'), #Set the axes color
        axis.title=element_text(size=14,face="bold"), #Set axis format
        panel.border = element_blank(), #Set the border
        panel.grid.major = element_blank(), #Set the major gridlines
        panel.grid.minor = element_blank(), #Set the minor gridlines
        text = element_text(size=18),  # set element text
        plot.background =element_blank(), #Set the plot background
        legend.key = element_blank()) + #Set plot legend key
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_rect(colour = "black", size=1))+
  theme(aspect.ratio=1)+
  ylab(expression(paste("temp"))) +
  ggtitle("UROP temp")+
  theme(plot.title = element_text(size=20, face = "italic"));temp_plot 


temp_plot<-ggplot(data=Mcap.temp.meta.melt, aes(x=datetime, y=temp)) +
  # geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
  #               width=0.1, show.legend = F)+
  #geom_point(aes(color=Treatment), size=4, show.legend = F)+
  geom_smooth( linetype=1, show.legend = F)+
  #scale_color_manual(values=c("dodgerblue3", "darkred"))+
  xlab("") + #Label the X Axis
  #ylim(0, 11) + #set Y limits
  #scale_y_log10()+
  theme_bw() + #Set the ITSkground color
  theme(axis.line = element_line(color = 'black'), #Set the axes color
        axis.title=element_text(size=14,face="bold"), #Set axis format
        panel.border = element_blank(), #Set the border
        panel.grid.major = element_blank(), #Set the major gridlines
        panel.grid.minor = element_blank(), #Set the minor gridlines
        text = element_text(size=18),  # set element text
        plot.background =element_blank(), #Set the plot background
        legend.key = element_blank()) + #Set plot legend key
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_rect(colour = "black", size=1))+
  theme(aspect.ratio=1)+
  ylab(expression(paste("temp"))) +
  ggtitle("UROP temp")+
  theme(plot.title = element_text(size=20, face = "italic"));temp_plot 

#summary stats

#summary T0-T1
Mcap.temp.T1 <- Mcap.temp.meta.melt %>%
                        filter(datetime >= as.Date('2017-10-29') & datetime <= as.Date('2017-11-29')) #

#mean of T0-T1
Mcap.temp.T1 %>%
  group_by(logger) %>%                                          # group by shade treatment
  summarise(meantemp = mean(temp, na.rm=T), sd=sd(temp, na.rm=T))  

#summary T1-T2
Mcap.temp.T2 <- Mcap.temp.meta.melt %>%
                        filter(datetime >= as.Date('2017-11-29') & datetime <= as.Date('2018-01-07')) #

#mean of T1-T2
Mcap.temp.T2 %>%
  group_by(logger) %>%                                          # group by shade treatment
  summarise(meantemp = mean(temp, na.rm=T), sd=sd(temp, na.rm=T))  

```

